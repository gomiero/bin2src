


use std::ptr;
use std::fs;
use std::io::{BufWriter, Write};

// Import the module generated by bin2src
mod lorem;

#[allow(dead_code)]
const AUTHOR:&'static str = "Alexandre Gomiero de Oliveira";
#[allow(dead_code)]
const REPO:&'static str = "https://github.com/gomiero/bin2src";

// Output buffer size
const BUFFER_OUT_SIZE: usize = 524_280;

// bzip2 contants used for decompress
const BZ_OK: i32 = 0;
const BZ_STREAM_END: i32 = 4;
const BZ_SEQUENCE_ERROR: i32 = -1;
const BZ_PARAM_ERROR: i32 = -2;
const BZ_MEM_ERROR: i32 = -3;
const BZ_DATA_ERROR: i32 = -4;
const BZ_OUTBUFF_FULL: i32 = -8;
const BZ_CONFIG_ERROR: i32 = -9;


// Functions imported statically from bzip2 lib
#[link(name = "libbz2", kind="static")]
extern "stdcall" {
    fn BZ2_bzDecompressInit (
	strm: &BzStream,
	verbosity: i32,
	small: i32
    ) -> i32;

    fn BZ2_bzDecompress ( 
	strm: &BzStream
    ) -> i32;

    fn BZ2_bzDecompressEnd ( 
	strm: &BzStream
    ) -> i32;
}

// Structure for data exchange with bzip2 lib
#[repr(C)]
#[derive(Debug)]
struct BzStream {
      next_in: *const u8,
      avail_in: u32,
      total_in_lo32: u32,
      total_in_hi32: u32,

      next_out: *mut u8,
      avail_out: u32,
      total_out_lo32: u32,
      total_out_hi32: u32,

      state: *mut i64,

      bzalloc: *mut i64,
      bzfree: *mut i64,
      opaque: *mut i64
}


// Main program structure
#[derive(Debug)]
struct BzUncompress {
    bzstream: BzStream,
    output_file: BufWriter<fs::File>
}

// Implementation for decompress process
impl BzUncompress {

    // Create a instance of BzUncompress and open the output file
    fn new(of: &'static str) -> Self {
	let of: BufWriter<fs::File> = match fs::OpenOptions::new()
	    .write(true)
	    .create(true)
	    .truncate(true)
	    .open(of) {
		Ok(f) => BufWriter::with_capacity(32768, f),
		_ => panic!("Error opening output file")
	    };
	BzUncompress {
	    bzstream: BzStream {
		next_in: ptr::null_mut(),
		avail_in: 0,
		total_in_hi32: 0,
		total_in_lo32: 0,

		next_out: ptr::null_mut(),
		avail_out: 0,
		total_out_hi32: 0,
		total_out_lo32: 0,

		state: ptr::null_mut(),

		bzalloc: ptr::null_mut(),
		bzfree: ptr::null_mut(),
		opaque: ptr::null_mut()
	    },
	    output_file: of
	}
    }

    // Init bzip2 lib for decopression
    fn decompress_init(&mut self) -> i32 {
	unsafe {
	    BZ2_bzDecompressInit(&self.bzstream, 4, 0)
	}
    }

    // Main decompress looping and output data to file
    fn decompress(&mut self) -> i32 {
	let buffer_out = [0u8; BUFFER_OUT_SIZE];
	let mut ret: i32;

	self.bzstream.next_in = lorem::LOREM_DATA.as_ptr() as *const u8;
	self.bzstream.avail_in = lorem::LOREM_SIZE as u32;
	loop {
	    self.bzstream.next_out = buffer_out.as_ptr() as *mut u8;
	    self.bzstream.avail_out = BUFFER_OUT_SIZE as u32;
	    unsafe {
		ret = BZ2_bzDecompress(&self.bzstream);
	    }
	    if ret == BZ_OK {
		self.output_file.write(&buffer_out[0..(BUFFER_OUT_SIZE - self.bzstream.avail_out as usize)]).unwrap();
		self.output_file.flush().unwrap();
		continue;
	    } else if ret == BZ_STREAM_END {
		self.output_file.write(&buffer_out[0..BUFFER_OUT_SIZE - self.bzstream.avail_out as usize]).unwrap();
		self.output_file.flush().unwrap();
		break;
	    } else {
		println!("Error: {}", ret);
		panic!("Error");
	    }
	}
	ret
    }

    // De-allocate bzip2 memory and structure
    fn decompress_end(&mut self) -> i32 {
	unsafe {
	    BZ2_bzDecompressEnd(&self.bzstream)
	}
    }
}

// Entry point
fn main() {
    let mut res: i32;
    let printerr = |e:i32| {
	match e {
	    BZ_SEQUENCE_ERROR => println!("Incorrect sequence call to decompress"),
	    BZ_PARAM_ERROR => println!("Parameter invalid"),
	    BZ_MEM_ERROR => println!("Error allocating or freeing memory"),
	    BZ_DATA_ERROR => println!("Data integrity error during decompression"),
	    BZ_OUTBUFF_FULL => println!("Output buffer is full"),
	    BZ_CONFIG_ERROR => println!("Config error"),
	    _ => println!("Unknow error")
	}	
    };
    let mut bzu: BzUncompress =  BzUncompress::new("lorem.out.txt");
    
    println!("Begin decompression...");
    res = bzu.decompress_init();
    if res != BZ_OK {
	printerr(res);
	return;
    };
    res =  bzu.decompress();
    if res != BZ_OK {
	printerr(res);
	return;
    };
    res = bzu.decompress_end();
        if res != BZ_OK {
	printerr(res);
	return;
    };
    println!("Decompress end.");
}
